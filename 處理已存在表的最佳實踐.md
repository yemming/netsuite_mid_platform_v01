# 處理已存在表的最佳實踐

## 問題場景

當你在 SQL 中已經手動創建了 `netsuite_account` 表，然後使用 Edge Function 進行同步時，應該如何處理？

## 最佳實踐方案

### 方案 1：直接使用現有表（推薦）✅

**優點：**
- 簡單快速
- 不需要額外操作
- Edge Function 會自動檢測表是否存在

**步驟：**
1. 確保表結構與 Edge Function 轉換的欄位匹配
2. Edge Function 會自動檢測表是否存在
3. 如果表存在，直接使用現有表進行插入/更新

**注意事項：**
- 確保表有 `id` 欄位作為主鍵（用於 `upsert` 的 `onConflict`）
- 確保欄位名稱與 Edge Function 轉換的欄位匹配（snake_case）
- 例如：`currencyPrecision` → `currency_precision`

### 方案 2：檢查並更新表結構

**使用場景：**
- 當 NetSuite 資料結構變化時
- 當需要添加新欄位時

**步驟：**
1. 使用 `ALTER TABLE` 添加缺失的欄位
2. 或者使用 `exec_sql` RPC 函數動態添加

```sql
-- 範例：為 netsuite_account 添加新欄位
ALTER TABLE netsuite_account 
ADD COLUMN IF NOT EXISTS new_field_name TEXT;
```

### 方案 3：清理並重建表

**使用場景：**
- 當表結構完全不符時
- 當需要重新開始同步時

**步驟：**
```sql
-- 1. 備份現有資料（如果需要）
CREATE TABLE netsuite_account_backup AS SELECT * FROM netsuite_account;

-- 2. 刪除舊表
DROP TABLE IF EXISTS netsuite_account;

-- 3. Edge Function 會自動創建新表（如果實作了動態創表）
-- 或手動創建表
```

## Edge Function 的處理邏輯

目前的 Edge Function 會：

1. ✅ **檢查表是否存在**：使用 `supabase.from(tableName).select("id").limit(1)`
2. ✅ **如果表存在**：直接使用，記錄日誌 `表 ${tableName} 已存在，將直接使用現有表結構`
3. ⚠️ **如果表不存在**：記錄警告，但仍嘗試插入（可能會失敗）

## 建議的表結構

### 必要欄位
```sql
- id (TEXT, PRIMARY KEY)
- netsuite_id (TEXT, NOT NULL)
- updated_at (TIMESTAMP)
- metadata (JSONB) -- 儲存完整的 NetSuite 記錄
```

### 範例：netsuite_account 表
```sql
CREATE TABLE netsuite_account (
  id TEXT PRIMARY KEY,
  netsuite_id TEXT NOT NULL,
  acct_number TEXT,
  acct_name TEXT NOT NULL,
  acct_type TEXT,
  acct_type_ref_name TEXT,
  is_inactive BOOLEAN,
  is_summary BOOLEAN,
  inventory BOOLEAN,
  eliminate BOOLEAN,
  include_children BOOLEAN,
  revalue BOOLEAN,
  cash_flow_rate TEXT,
  cash_flow_rate_ref_name TEXT,
  general_rate TEXT,
  general_rate_ref_name TEXT,
  subsidiary JSONB,
  localizations JSONB,
  metadata JSONB,
  last_modified_date TIMESTAMP,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

## 故障排除

### 問題 1：插入失敗，錯誤顯示欄位不存在

**原因：** 表結構與 Edge Function 轉換的欄位不匹配

**解決：**
1. 檢查 Edge Function 日誌，查看實際的欄位名稱
2. 使用 `ALTER TABLE` 添加缺失的欄位
3. 或更新表結構以匹配 Edge Function 的轉換邏輯

### 問題 2：插入失敗，錯誤顯示主鍵衝突

**原因：** `id` 欄位未設置為主鍵，或 `upsert` 的 `onConflict` 配置錯誤

**解決：**
```sql
-- 確保 id 是主鍵
ALTER TABLE netsuite_account ADD PRIMARY KEY (id);

-- 或使用 UNIQUE 約束
ALTER TABLE netsuite_account ADD CONSTRAINT netsuite_account_id_unique UNIQUE (id);
```

### 問題 3：資料類型不匹配

**原因：** 表欄位類型與 Edge Function 插入的資料類型不匹配

**解決：**
1. 檢查實際插入的資料類型（查看 `metadata` 欄位）
2. 使用 `ALTER TABLE` 修改欄位類型
3. 例如：`TEXT` 改為 `INTEGER`、`BOOLEAN` 等

## 最佳實踐總結

1. ✅ **優先使用現有表**：Edge Function 會自動檢測和使用
2. ✅ **確保表結構匹配**：特別是欄位名稱（snake_case）和必要欄位
3. ✅ **使用 `metadata` JSONB 欄位**：儲存完整的 NetSuite 記錄，即使欄位結構變化也能保留資料
4. ✅ **定期檢查表結構**：當 NetSuite 資料結構變化時，及時更新表結構

## 未來改進方向

1. **動態表結構同步**：Edge Function 自動檢測並添加缺失欄位
2. **表結構版本管理**：追蹤表結構版本，自動遷移
3. **智能欄位映射**：自動匹配欄位名稱和類型
